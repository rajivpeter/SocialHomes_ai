// ============================================================
// SocialHomes.Ai — Automatic Vulnerability Detection Service
// Differentiator 3: 7-factor weighted algorithm that identifies
// vulnerable tenants who may need proactive support.
// ============================================================

import { collections, getDocs, getDoc } from './firestore.js';
import { fetchWithCache } from './external-api.js';
import type { TenantDoc, PropertyDoc, CaseDoc } from '../models/firestore-schemas.js';

// ── Weights ──
const WEIGHTS = {
  deprivation: 0.20,
  arrears: 0.20,
  health: 0.15,
  isolation: 0.15,
  age: 0.10,
  dependents: 0.10,
  ucTransition: 0.10,
};

// ── Types ──
export type VulnerabilityLevel = 'low' | 'moderate' | 'high' | 'critical';

export interface VulnerabilityFactor {
  name: string;
  weight: number;
  rawScore: number;
  weightedScore: number;
  details: Record<string, unknown>;
}

export interface VulnerabilityAssessment {
  tenantId: string;
  tenantName: string;
  propertyAddress: string;
  overallScore: number;
  level: VulnerabilityLevel;
  factors: VulnerabilityFactor[];
  existingFlags: string[];
  newFlagsDetected: string[];
  recommendedActions: string[];
  assessedAt: string;
}

export interface VulnerabilityScan {
  scannedAt: string;
  totalTenants: number;
  results: {
    tenantId: string;
    tenantName: string;
    score: number;
    level: VulnerabilityLevel;
    newFlags: string[];
  }[];
  summary: {
    critical: number;
    high: number;
    moderate: number;
    low: number;
    newFlagsTotal: number;
  };
}

function classifyVulnerability(score: number): VulnerabilityLevel {
  if (score <= 25) return 'low';
  if (score <= 50) return 'moderate';
  if (score <= 75) return 'high';
  return 'critical';
}

// ── Factor 1: Deprivation (IMD) ──
async function calculateDeprivationFactor(postcode: string): Promise<VulnerabilityFactor> {
  let imdDecile = 5;
  let imdScore = 20;

  try {
    // First get LSOA from postcode
    const geoResp = await fetch(`https://api.postcodes.io/postcodes/${encodeURIComponent(postcode)}`);
    const geoJson = await geoResp.json() as { result?: { codes?: { lsoa?: string } } };
    const lsoaCode = geoJson.result?.codes?.lsoa;

    if (lsoaCode) {
      const result = await fetchWithCache(
        'imd',
        lsoaCode,
        90 * 24 * 3600,
        async () => {
          const url = `https://services1.arcgis.com/ESMARspQHYMw9BZ9/arcgis/rest/services/IMD_2019/FeatureServer/0/query` +
            `?where=lsoa11cd='${encodeURIComponent(lsoaCode)}'&outFields=*&f=json`;
          const resp = await fetch(url);
          if (!resp.ok) throw new Error(`ArcGIS IMD returned ${resp.status}`);
          const json = await resp.json() as any;
          const attrs = json.features?.[0]?.attributes;
          if (!attrs) throw new Error('LSOA not found');
          return {
            data: {
              imdDecile: attrs.IMDDecile ?? attrs.IMDDec0 ?? 5,
              imdScore: attrs.IMDScore ?? attrs.IMDScore0 ?? 20,
            } as Record<string, unknown>,
            httpStatus: 200,
          };
        },
        { imdDecile: 5, imdScore: 20 },
      );
      imdDecile = (result.data as any).imdDecile ?? 5;
      imdScore = (result.data as any).imdScore ?? 20;
    }
  } catch { /* use defaults */ }

  // IMD decile 1 = most deprived, 10 = least. Invert for scoring.
  const rawScore = Math.round(Math.max(0, Math.min(100, (11 - imdDecile) * 10)));

  return {
    name: 'Deprivation (IMD)',
    weight: WEIGHTS.deprivation,
    rawScore,
    weightedScore: Math.round(rawScore * WEIGHTS.deprivation * 100) / 100,
    details: { imdDecile, imdScore, postcode },
  };
}

// ── Factor 2: Arrears ──
function calculateArrearsFactor(tenant: TenantDoc): VulnerabilityFactor {
  const balance = tenant.rentBalance ?? 0;
  const weeklyCharge = tenant.weeklyCharge ?? 150;
  const weeksInArrears = balance < 0 ? Math.abs(balance) / Math.max(1, weeklyCharge) : 0;
  const arrearsRisk = tenant.arrearsRisk ?? 0;

  let rawScore = 0;
  if (weeksInArrears > 13) rawScore = 100;
  else if (weeksInArrears > 8) rawScore = 80;
  else if (weeksInArrears > 4) rawScore = 60;
  else if (weeksInArrears > 2) rawScore = 40;
  else if (weeksInArrears > 0) rawScore = 20;

  // Factor in predicted arrears risk
  rawScore = Math.round(rawScore * 0.7 + arrearsRisk * 0.3);

  return {
    name: 'Rent Arrears',
    weight: WEIGHTS.arrears,
    rawScore,
    weightedScore: Math.round(rawScore * WEIGHTS.arrears * 100) / 100,
    details: { balance, weeklyCharge, weeksInArrears: Math.round(weeksInArrears * 10) / 10, arrearsRisk },
  };
}

// ── Factor 3: Health Indicators ──
function calculateHealthFactor(tenant: TenantDoc, cases: CaseDoc[]): VulnerabilityFactor {
  const vulnFlags = tenant.vulnerabilityFlags ?? [];
  const healthFlags = vulnFlags.filter((v: any) => {
    const flag = (v.flag || v.type || v.name || '').toLowerCase();
    return flag.includes('health') || flag.includes('disability') || flag.includes('mental') || flag.includes('physical');
  });

  const dampCases = cases.filter(c => c.type === 'damp-mould' && c.propertyId);
  const hasActiveDamp = dampCases.some(c => c.status !== 'closed');

  let rawScore = healthFlags.length * 30;
  if (hasActiveDamp) rawScore += 20; // Damp/mould affects respiratory health
  rawScore = Math.min(100, rawScore);

  return {
    name: 'Health Indicators',
    weight: WEIGHTS.health,
    rawScore,
    weightedScore: Math.round(rawScore * WEIGHTS.health * 100) / 100,
    details: {
      healthFlagCount: healthFlags.length,
      flags: healthFlags.map((v: any) => v.flag || v.type || v.name),
      hasActiveDampCase: hasActiveDamp,
    },
  };
}

// ── Factor 4: Social Isolation ──
function calculateIsolationFactor(tenant: TenantDoc): VulnerabilityFactor {
  const contactCount = tenant.contactCount30Days ?? 0;
  const household = tenant.household ?? [];
  const livesAlone = household.length === 0;
  const lastContact = tenant.lastContact ? new Date(tenant.lastContact) : null;
  const daysSinceContact = lastContact ? Math.round((Date.now() - lastContact.getTime()) / (24 * 3600 * 1000)) : 90;

  let rawScore = 0;
  if (livesAlone) rawScore += 30;
  if (contactCount === 0) rawScore += 35;
  else if (contactCount < 2) rawScore += 15;
  if (daysSinceContact > 60) rawScore += 25;
  else if (daysSinceContact > 30) rawScore += 10;

  rawScore = Math.min(100, rawScore);

  return {
    name: 'Social Isolation',
    weight: WEIGHTS.isolation,
    rawScore,
    weightedScore: Math.round(rawScore * WEIGHTS.isolation * 100) / 100,
    details: { contactCount, livesAlone, daysSinceContact },
  };
}

// ── Factor 5: Age ──
function calculateAgeFactor(tenant: TenantDoc): VulnerabilityFactor {
  const dob = tenant.dob ? new Date(tenant.dob) : null;
  const age = dob ? Math.floor((Date.now() - dob.getTime()) / (365.25 * 24 * 3600 * 1000)) : 40;

  let rawScore = 0;
  if (age >= 80) rawScore = 90;
  else if (age >= 70) rawScore = 60;
  else if (age >= 65) rawScore = 40;
  else if (age <= 25) rawScore = 35; // Young tenants also at risk
  else if (age <= 18) rawScore = 50;

  return {
    name: 'Age Factor',
    weight: WEIGHTS.age,
    rawScore,
    weightedScore: Math.round(rawScore * WEIGHTS.age * 100) / 100,
    details: { dob: tenant.dob, age },
  };
}

// ── Factor 6: Dependents ──
function calculateDependentsFactor(tenant: TenantDoc): VulnerabilityFactor {
  const household = tenant.household ?? [];
  const children = household.filter((m: any) => {
    const rel = (m.relationship || '').toLowerCase();
    const age = m.age ?? 99;
    return rel.includes('child') || rel.includes('son') || rel.includes('daughter') || age < 18;
  });
  const dependents = household.filter((m: any) => {
    const rel = (m.relationship || '').toLowerCase();
    return rel.includes('depend') || rel.includes('carer');
  });

  let rawScore = 0;
  if (children.length >= 3) rawScore = 70;
  else if (children.length >= 2) rawScore = 50;
  else if (children.length >= 1) rawScore = 30;

  const hasInfant = children.some((c: any) => (c.age ?? 99) < 5);
  if (hasInfant) rawScore += 20;

  rawScore += dependents.length * 15;
  rawScore = Math.min(100, rawScore);

  return {
    name: 'Dependents',
    weight: WEIGHTS.dependents,
    rawScore,
    weightedScore: Math.round(rawScore * WEIGHTS.dependents * 100) / 100,
    details: { childrenCount: children.length, hasInfant, dependentsCount: dependents.length, householdSize: household.length + 1 },
  };
}

// ── Factor 7: UC Transition ──
function calculateUcTransitionFactor(tenant: TenantDoc): VulnerabilityFactor {
  const ucStatus = (tenant.ucStatus || '').toLowerCase();

  let rawScore = 0;
  if (ucStatus === 'transitioning') rawScore = 80;
  else if (ucStatus === 'pending') rawScore = 60;
  else if (ucStatus === 'managed-payment') rawScore = 40;
  else if (ucStatus === 'active') rawScore = 20;
  // 'not-applicable' or empty = 0

  return {
    name: 'UC Transition',
    weight: WEIGHTS.ucTransition,
    rawScore,
    weightedScore: Math.round(rawScore * WEIGHTS.ucTransition * 100) / 100,
    details: { ucStatus: tenant.ucStatus || 'not-applicable' },
  };
}

// ── Detect New Flags ──
function detectNewFlags(factors: VulnerabilityFactor[], existingFlags: string[]): string[] {
  const existing = new Set(existingFlags.map(f => f.toLowerCase()));
  const newFlags: string[] = [];

  const deprivation = factors.find(f => f.name === 'Deprivation (IMD)');
  if (deprivation && deprivation.rawScore > 70 && !existing.has('deprivation')) {
    newFlags.push('High deprivation area');
  }

  const arrears = factors.find(f => f.name === 'Rent Arrears');
  if (arrears && (arrears.details.weeksInArrears as number) > 8 && !existing.has('financial hardship')) {
    newFlags.push('Financial hardship (8+ weeks arrears)');
  }

  const isolation = factors.find(f => f.name === 'Social Isolation');
  if (isolation && isolation.rawScore > 60 && !existing.has('social isolation')) {
    newFlags.push('Social isolation risk');
  }

  const age = factors.find(f => f.name === 'Age Factor');
  if (age && (age.details.age as number) >= 70 && !existing.has('elderly')) {
    newFlags.push('Elderly tenant (70+)');
  }

  const dependents = factors.find(f => f.name === 'Dependents');
  if (dependents && (dependents.details.hasInfant as boolean) && !existing.has('household with infant')) {
    newFlags.push('Household with infant');
  }

  const uc = factors.find(f => f.name === 'UC Transition');
  if (uc && uc.rawScore >= 60 && !existing.has('uc transition')) {
    newFlags.push('Universal Credit transition risk');
  }

  return newFlags;
}

// ── Recommended Actions ──
function generateActions(level: VulnerabilityLevel, factors: VulnerabilityFactor[], newFlags: string[]): string[] {
  const actions: string[] = [];

  if (level === 'critical') {
    actions.push('Assign dedicated support officer for intensive case management');
    actions.push('Schedule welfare visit within 5 working days');
  } else if (level === 'high') {
    actions.push('Schedule welfare check within 10 working days');
  }

  const arrears = factors.find(f => f.name === 'Rent Arrears');
  if (arrears && arrears.rawScore > 50) {
    actions.push('Refer to Money Advice Service for benefits maximisation');
    actions.push('Review affordability and explore payment arrangements');
  }

  const isolation = factors.find(f => f.name === 'Social Isolation');
  if (isolation && isolation.rawScore > 50) {
    actions.push('Refer to community inclusion programme');
    actions.push('Arrange regular welfare calls (fortnightly minimum)');
  }

  const health = factors.find(f => f.name === 'Health Indicators');
  if (health && health.rawScore > 50) {
    actions.push('Review property adaptations and Disabled Facilities Grant eligibility');
  }

  const uc = factors.find(f => f.name === 'UC Transition');
  if (uc && uc.rawScore >= 60) {
    actions.push('Apply for UC Alternative Payment Arrangement (APA) for direct rent payment');
  }

  if (newFlags.length > 0) {
    actions.push(`Update vulnerability record with ${newFlags.length} newly detected flag(s)`);
  }

  if (actions.length === 0) {
    actions.push('Continue standard monitoring — no immediate action required');
  }

  return actions;
}

// ── Main: Single Tenant Assessment ──
export async function assessVulnerability(tenantId: string): Promise<VulnerabilityAssessment> {
  const tenant = await getDoc<TenantDoc>(collections.tenants, tenantId);
  if (!tenant) throw new Error(`Tenant ${tenantId} not found`);

  const property = await getDoc<PropertyDoc>(collections.properties, tenant.propertyId);
  const tenantCases = await getDocs<CaseDoc>(collections.cases, [
    { field: 'tenantId', op: '==', value: tenantId },
  ]);

  // Calculate all factors
  const deprivationFactor = await calculateDeprivationFactor(property?.postcode || 'SE15 4QN');
  const arrearsFactor = calculateArrearsFactor(tenant);
  const healthFactor = calculateHealthFactor(tenant, tenantCases);
  const isolationFactor = calculateIsolationFactor(tenant);
  const ageFactor = calculateAgeFactor(tenant);
  const dependentsFactor = calculateDependentsFactor(tenant);
  const ucFactor = calculateUcTransitionFactor(tenant);

  const factors = [deprivationFactor, arrearsFactor, healthFactor, isolationFactor, ageFactor, dependentsFactor, ucFactor];
  const overallScore = Math.round(factors.reduce((sum, f) => sum + f.weightedScore, 0));
  const level = classifyVulnerability(overallScore);

  const existingFlags = (tenant.vulnerabilityFlags ?? []).map((v: any) => v.flag || v.type || v.name || '');
  const newFlagsDetected = detectNewFlags(factors, existingFlags);
  const recommendedActions = generateActions(level, factors, newFlagsDetected);

  return {
    tenantId: tenant.id,
    tenantName: `${tenant.title} ${tenant.firstName} ${tenant.lastName}`,
    propertyAddress: property?.address || 'Unknown',
    overallScore,
    level,
    factors,
    existingFlags,
    newFlagsDetected,
    recommendedActions,
    assessedAt: new Date().toISOString(),
  };
}

// ── Batch Scan ──
export async function scanAllTenants(): Promise<VulnerabilityScan> {
  const tenants = await getDocs<TenantDoc>(collections.tenants);

  const results = await Promise.all(
    tenants.map(async (t) => {
      try {
        const assessment = await assessVulnerability(t.id);
        return {
          tenantId: t.id,
          tenantName: assessment.tenantName,
          score: assessment.overallScore,
          level: assessment.level,
          newFlags: assessment.newFlagsDetected,
        };
      } catch {
        return {
          tenantId: t.id,
          tenantName: `${t.title} ${t.firstName} ${t.lastName}`,
          score: 0,
          level: 'low' as VulnerabilityLevel,
          newFlags: [],
        };
      }
    }),
  );

  // Sort by score descending
  results.sort((a, b) => b.score - a.score);

  return {
    scannedAt: new Date().toISOString(),
    totalTenants: results.length,
    results,
    summary: {
      critical: results.filter(r => r.level === 'critical').length,
      high: results.filter(r => r.level === 'high').length,
      moderate: results.filter(r => r.level === 'moderate').length,
      low: results.filter(r => r.level === 'low').length,
      newFlagsTotal: results.reduce((s, r) => s + r.newFlags.length, 0),
    },
  };
}
